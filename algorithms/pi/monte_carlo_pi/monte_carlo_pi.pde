// Code by github.com/S1r0hub
// Created: 07.08.2020
// Processing Version: 3.5.4
//
// This code creates an approximation of Pi using Monte-Carlo Algorithm.
// The process is visualized by drawing points inside/outside the circle.
//
// Pi is approximated by: 4 * (hits / total)
// (hits = points inside the circle)
//
// Interaction is possible using the following keys:
// [RIGHT] - reduce amount of points generated per iteration
// [LEFT] - increase amount of points generated per iteration
// 
// If you use it or any of the results generated by it,
// please reference this project as the source.
// Thanks.

int border = 10;
int rect_width = 512;

// initial points per iteration
int speed = 5000;

// changed during execution
int hits = 0, miss = 0;
int lastTime = 0;
boolean kLt, kRt;

// collect the last "errors" iterations error values
int errors = 100;

// collects the absolute errors of the approximaton to pi
import java.util.ArrayDeque;
ArrayDeque<Float> errorList = new ArrayDeque<Float>(errors);


void setup() {
  
  size(1024,512);
  background(255,255,255,255);
  stroke(color(20,20,20));
  
  rect(border, border, rect_width-(border*2)+1, height-(border*2)+1);
  //circle(rect_width/2, height/2, rect_width-(border*2));
}


void draw() {

  // only run code below every second
  if (millis() < lastTime + 1000) { return; }
  
  // take timestamp to wait for next iteration
  lastTime = millis();
  println("Drawing next points...");
  
  int hits_prev = hits;
  int miss_prev = miss;
  
  // Arrays to store points outside circle
  // x positions, y positions, color
  int px[] = new int[speed];
  int py[] = new int[speed];
  int pc[] = new int[speed];
  int out_index = 0;
  
  int xw = rect_width - border*2;
  int yh = height - border*2;
  
  // Shape to render points inside circle
  PShape ps = createShape();
  ps.beginShape(POINTS);
  
  // generate random points
  for (int i = 0; i < speed; i++) {
    
    // generate points within range [-1, 1]
    // then calculate d = distance from circle center
    float x = random(2.f)-1.f, y = random(2.f)-1.f;
    float d = sqrt(x*x + y*y);
    boolean inside = d <= 1 ? true : false;

    // set color for points inside/outside
    // and calculate their positions for drawing
    int c = inside ? color(100,100,255) : color(255,180,100);
    int xpos = border + (rect_width-border*2)/2 + floor(x * 0.5f * xw) + 1;
    int ypos = border + (height-border*2)/2 + floor(y * 0.5f * yh) + 1;
 
    if (inside) {
      hits++;
      ps.stroke(c);
      ps.vertex(xpos, ypos);
    }
    else {
      miss++;
      out_index++;
      pc[out_index] = c;
      px[out_index] = xpos; py[out_index] = ypos;
    }
  }
  
  ps.endShape();
  shape(ps);
  
  // draw points outside of circle
  PShape ps_o = createShape();
  ps_o.beginShape(POINTS);
  for (int i = 0; i < miss - miss_prev; i++) {
    ps_o.stroke(pc[i]);
    ps_o.vertex(px[i], py[i]);
  }
  ps_o.endShape();
  shape(ps_o);
  
  // calculate quarter pi
  float quarter_pi = hits / (float)(hits+miss);
  float error = abs(QUARTER_PI - quarter_pi);
  
  // store error in list
  if (errorList.size() >= errors) { errorList.removeLast(); }
  errorList.push(error);
  
  // Console printout
  println("Current: Hits=" + String.valueOf(hits-hits_prev) + ", Miss=" + String.valueOf(miss-miss_prev));
  println("Total: Hits=" + String.valueOf(hits) + ", Miss=" + String.valueOf(miss));
  String piStr = "Pi = " + String.valueOf(quarter_pi * 4.f);
  println(piStr);
  println("Error = " + String.valueOf(error));

  // ----------------------------------------
  // clear right side of window
  fill(255);
  stroke(255);
  rect(rect_width+border, border, width-rect_width-(border*2)+1, height-(border*2)+1);
  
  // visual printout
  fill(0);
  textSize(20);
  textAlign(LEFT, TOP);
  text("Points per Iteration: " + String.valueOf(speed), rect_width+border, border);
  text("Hits: " + String.valueOf(hits) + "/" + String.valueOf(hits+miss), rect_width+border, border+25);
  text(piStr, rect_width+border, border+50);
  
  // draw error graph
  int start_height = 80;
  int graph_width = width-rect_width-(border*2)+1;
  int graph_height = height-(border*2+start_height)+1;
  stroke(0);
  fill(255);
  rect(rect_width+border, border+start_height, graph_width, graph_height);
  
  if (errorList.size() > 1) {
    
    int x_start = rect_width+border+1;
    int y_start = height-border-1;
    float x_dist = graph_width / (float) errors;
    
    // get maximum error in list
    float error_max = 0;
    float error_min = 9999999;
    for (float e : errorList) {
      if (e > error_max) { error_max = e; }
      if (e < error_min) { error_min = e; }
    }
    
    fill(0);
    textSize(14);
    text("Max Error = " + String.valueOf(error_max), x_start + 10, y_start - graph_height + 10);
    text("Min Error = " + String.valueOf(error_min), x_start + 10, y_start - graph_height + 30);
    text("Cur Error = " + String.valueOf(error), x_start + 10, y_start - graph_height + 50);
    fill(255);
    
    int i = 0;
    float prev_e = -1;
    for (float e : errorList) {
      
      if (i > 0) {
        int x0 = x_start + floor(x_dist * (i-1));
        int x1 = x_start + floor(x_dist * i);
        int y0 = y_start - floor(prev_e / error_max * (graph_height-2));
        int y1 = y_start - floor(e / error_max * (graph_height-2));
        stroke(color(50,50,220));
        line(x0,y0,x1,y1);
      }
      
      prev_e = e;
      i++;
    }
  }
}


void keyPressed() {

  if (!kRt && keyCode == RIGHT) {

    kRt = true;
    if (speed < 10) { speed++; }
    else if (speed < 100) { speed += 10; }
    else if (speed < 1000) { speed += 100; }
    else if (speed < 10000) { speed += 1000; }
    else if (speed < 50000) { speed += 10000; }
    println("Speed: " + String.valueOf(speed));
  }
  else if (!kLt && keyCode == LEFT) {

    kLt = true;
    if (speed > 10000) { speed -= 10000; }
    else if (speed > 1000) { speed -= 1000; }
    else if (speed > 100) { speed -= 100; }
    else if (speed > 10) { speed -= 10; }
    else if (speed > 0) { speed--; }
    println("Speed: " + String.valueOf(speed));
  }
}

void keyReleased() {
  if (keyCode == LEFT) { kLt = false; }
  else if (keyCode == RIGHT) { kRt = false; }
}
