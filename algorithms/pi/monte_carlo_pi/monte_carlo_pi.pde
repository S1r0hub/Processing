// Code by github.com/S1r0hub
// Created: 07.08.2020
// Processing Version: 3.5.4
//
// This code creates an approximation of Pi using Monte-Carlo Algorithm.
// The process is visualized by drawing points inside/outside the circle.
//
// Pi is approximated by: 4 * (hits / total)
// (hits = points inside the circle)
//
// Interaction is possible using the following keys:
// [RIGHT] - reduce amount of points generated per iteration
// [LEFT] - increase amount of points generated per iteration
// 
// If you use it or any of the results generated by it,
// please reference this project as the source.
// Thanks.

int border = 10;

// initial points per iteration
int speed = 100;

// changed during execution
int hits = 0, miss = 0;
int lastTime = 0;
boolean kLt, kRt;


void setup() {
  
  size(512,512);
  background(255,255,255,255);
  stroke(color(20,20,20));
  rect(border, border, width-(border*2)+1, height-(border*2)+1);
  //circle(width/2, height/2, width-(border*2));
}


void draw() {

  // only run code below every 2 seconds
  if (millis() < lastTime + 1000*2) { return; }
  
  // take timestamp to wait for next iteration
  lastTime = millis();
  println("Drawing next points...");
  
  int hits_prev = hits;
  int miss_prev = miss;
  
  // Arrays to store points outside circle
  // x positions, y positions, color
  int px[] = new int[speed];
  int py[] = new int[speed];
  int pc[] = new int[speed];
  int out_index = 0;
  
  int xw = width - border*2;
  int yh = height - border*2;
  
  // Shape to render points inside circle
  PShape ps = createShape();
  ps.beginShape(POINTS);
  
  // generate random points
  for (int i = 0; i < speed; i++) {
    
    // generate points within range [-1, 1]
    // then calculate d = distance from circle center
    float x = random(2.f)-1.f, y = random(2.f)-1.f;
    float d = sqrt(x*x + y*y);
    boolean inside = d <= 1 ? true : false;

    // set color for points inside/outside
    // and calculate their positions for drawing
    int c = inside ? color(100,100,255) : color(255,180,100);
    int xpos = border + (width-border*2)/2 + floor(x * 0.5f * xw) + 1;
    int ypos = border + (height-border*2)/2 + floor(y * 0.5f * yh) + 1;
 
    if (inside) {
      hits++;
      ps.stroke(c);
      ps.vertex(xpos, ypos);
    }
    else {
      miss++;
      out_index++;
      pc[out_index] = c;
      px[out_index] = xpos; py[out_index] = ypos;
    }
  }
  
  ps.endShape();
  shape(ps);
  
  // draw points outside of circle
  PShape ps_o = createShape();
  ps_o.beginShape(POINTS);
  for (int i = 0; i < miss - miss_prev; i++) {
    ps_o.stroke(pc[i]);
    ps_o.vertex(px[i], py[i]);
  }
  ps_o.endShape();
  shape(ps_o);
  
  println("Current: Hits=" + String.valueOf(hits-hits_prev) + ", Miss=" + String.valueOf(miss-miss_prev));
  println("Total: Hits=" + String.valueOf(hits) + ", Miss=" + String.valueOf(miss));
  println("Pi = " + String.valueOf(hits / (float)(hits+miss) * 4.f));
}


void keyPressed() {

  if (!kRt && keyCode == RIGHT) {

    kRt = true;
    if (speed < 10) { speed++; }
    else if (speed < 100) { speed += 10; }
    else if (speed < 1000) { speed += 100; }
    else if (speed < 10000) { speed += 1000; }
    else if (speed < 50000) { speed += 10000; }
    println("Speed: " + String.valueOf(speed));
  }
  else if (!kLt && keyCode == LEFT) {

    kLt = true;
    if (speed > 10000) { speed -= 10000; }
    else if (speed > 1000) { speed -= 1000; }
    else if (speed > 100) { speed -= 100; }
    else if (speed > 10) { speed -= 10; }
    else if (speed > 0) { speed--; }
    println("Speed: " + String.valueOf(speed));
  }
}

void keyReleased() {
  if (keyCode == LEFT) { kLt = false; }
  else if (keyCode == RIGHT) { kRt = false; }
}
